# HG changeset patch
# User Matti Picus <matti.picus@gmail.com>
# Date 1625384188 -10800
#      Sun Jul 04 10:36:28 2021 +0300
# Branch py3.7
# Node ID 66c38129f52afd4c3a6ed74f534468e6f5085695
# Parent  749448488ccd6d138a2dbd392c0ade9b75c2795b
remove hack to look up function by offset, not needed by numpy since v1.17

Does not work properly on win64
https://github.com/numpy/numpy/pull/12524, merged in 2018

diff -r 749448488ccd -r 66c38129f52a pypy/module/_hpy_universal/interp_cpy_compat.py
--- a/pypy/module/_hpy_universal/interp_cpy_compat.py	Sat Jul 03 23:35:10 2021 +0300
+++ b/pypy/module/_hpy_universal/interp_cpy_compat.py	Sun Jul 04 10:36:28 2021 +0300
@@ -134,7 +134,7 @@
                 # XXX: we probably need to handle manually these slots
                 raise NotImplementedError("slot wrapper for slot %d" % num)
             funcptr = slotdef.c_pfunc
-            w_wrapper = wrapper_class(space, w_type, method_name, doc, funcptr, offset=[])
+            w_wrapper = wrapper_class(space, w_type, method_name, doc, funcptr)
             w_type.setdictvalue(space, method_name, w_wrapper)
             break
     else:
diff -r 749448488ccd -r 66c38129f52a pypy/module/cpyext/methodobject.py
--- a/pypy/module/cpyext/methodobject.py	Sat Jul 03 23:35:10 2021 +0300
+++ b/pypy/module/cpyext/methodobject.py	Sun Jul 04 10:36:28 2021 +0300
@@ -301,14 +301,11 @@
     """
     Abstract class; for concrete subclasses, see slotdefs.py
     """
-    _immutable_fields_ = ['offset[*]']
-
-    def __init__(self, space, w_type, method_name, doc, func, offset):
+    def __init__(self, space, w_type, method_name, doc, func):
         self.space = space
         self.method_name = method_name
         self.doc = doc
         self.func = func
-        self.offset = offset
         assert isinstance(w_type, W_TypeObject)
         self.w_objclass = w_type
 
@@ -318,25 +315,8 @@
     def call(self, space, w_self, __args__):
         raise NotImplementedError
 
-    @jit.unroll_safe
     def get_func_to_call(self):
-        func_to_call = self.func
-        if self.offset:
-            pto = as_pyobj(self.space, self.w_objclass)
-            # make ptr the equivalent of this, using the offsets
-            #func_to_call = rffi.cast(rffi.VOIDP, ptr.c_tp_as_number.c_nb_multiply)
-            if pto:
-                cptr = rffi.cast(rffi.CCHARP, pto)
-                for o in self.offset:
-                    ptr = rffi.cast(rffi.VOIDPP, rffi.ptradd(cptr, o))[0]
-                    cptr = rffi.cast(rffi.CCHARP, ptr)
-                func_to_call = rffi.cast(rffi.VOIDP, cptr)
-            else:
-                # Should never happen, assert to get a traceback
-                assert False, "failed to convert w_type %s to PyObject" % str(
-                                                              self.w_objclass)
-        assert func_to_call
-        return func_to_call
+        return self.func
 
     def check_args(self, __args__, arity):
         length = len(__args__.arguments_w)
diff -r 749448488ccd -r 66c38129f52a pypy/module/cpyext/typeobject.py
--- a/pypy/module/cpyext/typeobject.py	Sat Jul 03 23:35:10 2021 +0300
+++ b/pypy/module/cpyext/typeobject.py	Sun Jul 04 10:36:28 2021 +0300
@@ -353,7 +353,6 @@
     for method_name, slot_names, wrapper_class, doc in slotdefs_for_wrappers:
         if method_name in dict_w:
             continue
-        offset = [rffi.offsetof(lltype.typeOf(pto).TO, slot_names[0])]
         if len(slot_names) == 1:
             func = getattr(pto, slot_names[0])
             if slot_names[0] == 'c_tp_hash':
@@ -370,7 +369,6 @@
             struct = getattr(pto, slot_names[0])
             if not struct:
                 continue
-            offset.append(rffi.offsetof(lltype.typeOf(struct).TO, slot_names[1]))
             func = getattr(struct, slot_names[1])
         func_voidp = rffi.cast(rffi.VOIDP, func)
         if not func:
@@ -380,8 +378,7 @@
 
         assert issubclass(wrapper_class, W_PyCWrapperObject)
 
-        w_obj = wrapper_class(space, w_type, method_name, doc, func_voidp,
-                              offset=offset[:])
+        w_obj = wrapper_class(space, w_type, method_name, doc, func_voidp)
         dict_w[method_name] = w_obj
     if pto.c_tp_doc:
         raw_doc = rffi.constcharp2str(pto.c_tp_doc)
