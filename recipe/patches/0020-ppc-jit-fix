diff -r 365e2d713697 -r c61a69876e5b rpython/jit/backend/ppc/opassembler.py
--- rpython/jit/backend/ppc/opassembler.py
+++ rpython/jit/backend/ppc/opassembler.py
@@ -755,13 +755,19 @@
     def _apply_offset(self, index_loc, ofs_loc):
         # If offset != 0 then we have to add it here.  Note that
         # mc.addi() would not be valid with operand r0.
-        assert ofs_loc.is_imm()                # must be an immediate...
-        assert _check_imm_arg(ofs_loc.getint())   # ...that fits 16 bits
         assert index_loc.is_core_reg()
         assert index_loc is not r.SCRATCH2
-        # (simplified version of _apply_scale())
-        if ofs_loc.value > 0:
-            self.mc.addi(r.SCRATCH2.value, index_loc.value, ofs_loc.value)
+        if ofs_loc.is_imm():
+            # if it is an immediate, it must fit into 16 bits
+            assert _check_imm_arg(ofs_loc.getint())
+            # (simplified version of _apply_scale())
+            if ofs_loc.value != 0:
+                self.mc.addi(r.SCRATCH2.value, index_loc.value, ofs_loc.value)
+                index_loc = r.SCRATCH2
+        else:
+            # larger immediates are loaded into a register in regalloc.py
+            assert ofs_loc.is_core_reg()
+            self.mc.add(r.SCRATCH2.value, index_loc.value, ofs_loc.value)
             index_loc = r.SCRATCH2
         return index_loc
 
diff -r 365e2d713697 -r c61a69876e5b rpython/jit/backend/ppc/regalloc.py
--- rpython/jit/backend/ppc/regalloc.py
+++ rpython/jit/backend/ppc/regalloc.py
@@ -771,7 +771,7 @@
         value_loc = self.ensure_reg(op.getarg(2))
         assert op.getarg(3).getint() == 1    # scale
         ofs_loc = self.ensure_reg_or_16bit_imm(op.getarg(4))
-        assert ofs_loc.is_imm()  # the arg(4) should always be a small constant
+        # the arg(4) is often a small constant, but it may be too large
         size_loc = self.ensure_reg_or_any_imm(op.getarg(5))
         return [base_loc, index_loc, value_loc, ofs_loc, size_loc]
 
@@ -780,7 +780,7 @@
         index_loc = self.ensure_reg(op.getarg(1))
         assert op.getarg(2).getint() == 1    # scale
         ofs_loc = self.ensure_reg_or_16bit_imm(op.getarg(3))
-        assert ofs_loc.is_imm()  # the arg(3) should always be a small constant
+        # the arg(3) is often a small constant, but it may be too large
         self.free_op_vars()
         res_loc = self.force_allocate_reg(op)
         size_box = op.getarg(4)
